<!doctype html>
<meta charset="utf-8"/>

<title>Learning from Machines</title>
<link rel=stylesheet href=base.less>
<link rel=stylesheet href=title.less>
<link rel=stylesheet href=hallucinations.less>
<link rel=stylesheet href=inside.less>
<link rel=stylesheet href=dreams.less>
<link rel=stylesheet href=stones.less>

<script src=main.js></script>
<script src=create.js></script>
<script>
  const {min, max} = Math
</script>

<!-- Introduction -->
<div id=titleCard class=vbox>
  <type-writer id=titleWriter></type-writer>
</div>
<build-note id=titleBlank            data-title=""></build-note>
<build-note id=titleLfm              data-title="learning from machines"></build-note>
<build-note id=titleLfmErased        data-title=""></build-note>
<script>
  When()
    .withName('titleWriter')
    .changed((_, current, prev) => {
      if (current.dataset.title)
        return titleWriter.text = current.dataset.title
      titleWriter.text = ''
    })
</script>

<!-- 1. hallucinations -->
<div id=hallucinations class=seed>
  <build-note id=title1                data-title="1. "></build-note>
  <build-note id=title1Hallucinations  data-title="1. hallucinations"></build-note>      
  
  <!-- 1a. the inception neural network -->
  <img id=inceptionDiagram src=inception-diagram.svg>
  <div id=deepDreamOutputLayer>
    <span class=P>cat</span>
    <span class=P>dog</span>
    <span class=P>person</span>
    <span class=P>banana</span>
    <span class=P>toaster</span>
    </div>
  <video id=skully src=brain-skull-to-vision.m4v is=seekable-video preload></video>
  <video id=deepDream src=miquel_pn_deep_dream.mp4 preload></video>
  <type-writer id=miquel></type-writer>
  <div id=deepDreamLayers class=stopped>
    <type-writer id=deepDreamCurrentLayer></type-writer>
  </div>        
  <div id=deepDreamInputLayer>
    <canvas id=deepDreamInputPixels></canvas>
  </div>
  <div id=deepDreamInputLayerReceptiveField>
    <div id=deepDreamReceptiveFieldHighlight></div>
  </div>
  <div id=deepDreamConvOutput>
    <script>
      for (let r = 0; r !== 5; ++r) {
        document.write(`<div class="row row-${r}">`)
        for (let c = 0; c !== 5; ++c) {
          document.write(`<div class="cell cell-${r}-${c}"></div>`)
        }
        document.write(`</div>`)
      }
    </script>
  </div>
  <type-writer id=deepDreamConvFilter></type-writer>
  <script>
    const layers = ["Initial input data", "conv1/7x7_s2", "pool1/3x3_s2", "pool1/norm1", "conv2/3x3_reduce", "conv2/3x3", "conv2/norm2", "pool2/3x3_s2", "inception_3a/1x1", "inception_3a/3x3_reduce", "inception_3a/3x3", "inception_3a/5x5_reduce", "inception_3a/5x5", "inception_3a/pool", "inception_3a/pool_proj", "inception_3a/output", "inception_3b/1x1", "inception_3b/3x3_reduce", "inception_3b/3x3", "inception_3b/5x5_reduce", "inception_3b/5x5", "inception_3b/pool", "inception_3b/pool_proj", "inception_3b/output", "pool3/3x3_s2", "inception_4a/1x1", "inception_4a/3x3_reduce", "inception_4a/3x3", "inception_4a/5x5_reduce", "inception_4a/5x5", "inception_4a/pool", "inception_4a/pool_proj", "inception_4a/output", "inception_4b/1x1", "inception_4b/3x3_reduce", "inception_4b/3x3", "inception_4b/5x5_reduce", "inception_4b/5x5", "inception_4b/pool", "inception_4b/pool_proj", "inception_4b/output", "inception_4c/1x1", "inception_4c/3x3_reduce", "inception_4c/3x3", "inception_4c/5x5_reduce", "inception_4c/5x5", "inception_4c/pool", "inception_4c/pool_proj", "inception_4c/output", "inception_4d/1x1", "inception_4d/3x3_reduce", "inception_4d/3x3", "inception_4d/5x5_reduce", "inception_4d/5x5", "inception_4d/pool", "inception_4d/pool_proj", "inception_4d/output", "inception_4e/1x1", "inception_4e/3x3_reduce", "inception_4e/3x3", "inception_4e/5x5_reduce", "inception_4e/5x5", "inception_4e/pool", "inception_4e/pool_proj", "inception_4e/output", "pool4/3x3_s2", "inception_5a/1x1", "inception_5a/3x3_reduce", "inception_5a/3x3", "inception_5a/5x5_reduce", "inception_5a/5x5", "inception_5a/pool", "inception_5a/pool_proj", "inception_5a/output", "inception_5b/1x1", "inception_5b/3x3_reduce", "inception_5b/3x3", "inception_5b/5x5_reduce", "inception_5b/5x5", "inception_5b/pool", "inception_5b/pool_proj", "inception_5b/output", "pool5/7x7_s1"]      
    deepDream.onloadedmetadata = () => {
      const timeAtEachLayer = deepDream.duration / layers.length
      deepDream.timeline = Timeline(
          layers.map((layer, i) => ({
            at: i * timeAtEachLayer, layer
          }))
        )
    }
  </script>
  <script src=inception.js></script>
  <build-note id=dreamFullscreenPaused></build-note>
  <build-note id=dreamFullscreenMiquel></build-note>
  <script>
    When(dreamFullscreenMiquel)
      .start(() => miquel.text = 'Miquel PerellÃ³ Nieto')
      .end(() => miquel.text = '')
  </script>
  <build-note id=dreamFullscreenPlaying></build-note>
  <build-note id=dreamFullscreenShowLayer></build-note>
  <build-note id=inception></build-note>
  <build-note id=inceptionFromInput></build-note>
  <build-note id=inceptionToOutput></build-note>
  <build-note id=inceptionConv></build-note>
  <build-note id=inceptionConvForward></build-note>
  <build-note id=inceptionConvTraining></build-note>
  <build-note id=inceptionIncepting></build-note>
  <build-note id=inceptionPanDiagram></build-note>
  <build-note id=dreamFullscreenPlayingAgain></build-note>
  <script>
    When(dreamFullscreenPaused)
      .start(() => {
        deepDream.currentTime = 0
        deepDream.pause()
      })
    When(buildInRange(dreamFullscreenMiquel, dreamFullscreenPlayingAgain))
      .start(() => {
        deepDream.play()
      })
      .frame(() => {
        if (!deepDream.timeline) return
        deepDreamCurrentLayer.text = deepDream.timeline(deepDream).layer
      })

    inceptionPixelsViz(
      buildInRange(inception, inceptionPanDiagram),
      deepDream,
      deepDreamInputPixels
    )

    When(inceptionConvTraining).frame(every(2[sec]) (() =>
      deepDreamConvFilter.text = randomMatrix(3, 3)
    ))

    const randomRow = w => () => new Array(w).fill(0)
      .map((() => Math.random().toString().substr(0, 3) + ' '))
      .join('') + '\n'
    const randomMatrix = (w, h) =>
      '[\n' + new Array(h).fill(0).map(randomRow(w)).join('') + ']'
  </script>  
  
  <!-- 1b. The human visual system -->
  <build-note id=inside></build-note>
  <build-note id=insideEnterSkully></build-note>
  <build-note id=insideLessCruft></build-note>
  <build-note id=insideRetina></build-note>
  <build-note id=insideRetinaGanglions></build-note>
  <build-note id=insideRetinaEtc></build-note>
  <build-note id=insideRetinaPhotoreceptors></build-note>
  <build-note id=insideRetinaLightGoesIn></build-note>
  <build-note id=insideRetinaSignalComesOut></build-note>
  <build-note id=insideRetinaOpticNerve></build-note>
  <build-note id=insideRetinaReceptiveField></build-note>
  <build-note id=insideRetinaReceptiveFieldFiringWeakly></build-note>
  <build-note id=insideRetinaReceptiveFieldOffCenterFiring></build-note>
  <build-note id=insideRetinaReceptiveFieldOffCenterDead></build-note>
  <build-note id=insideRetinaReceptiveFieldOnCenterFiring></build-note>
  <build-note id=insideThroughTheBrain></build-note>
  <build-note id=insideVisualCortex></build-note>
  <script>
    insideEnterSkully.skully = {time: 0, paused: true}
    insideLessCruft.skully = {time: 14.8, duration: 5, paused: true}
    insideRetina.skully = {time: 20, duration: 20 - 14.8, paused: true}
    insideRetinaGanglions.skully = {time: 29, duration: 29 - 20, paused: true}
    insideRetinaEtc.skully = {time: 31, duration: 31 - 29, paused: true}
    insideRetinaPhotoreceptors.skully = {time: 34, duration: 34 - 31, paused: true}
    insideRetinaLightGoesIn.skully = {time: 34.5, duration: 34.5 - 34, paused: true}
    insideRetinaSignalComesOut.skully = {time: 36.5, duration: 36.5 - 34.5, paused: true}
    insideRetinaOpticNerve.skully = {time: 42, duration: 42 - 36.5, paused: true}
    insideRetinaReceptiveField.skully = {time: 50.84, duration: 50.8 - 42, paused: true}
    insideRetinaReceptiveFieldFiringWeakly.skully = {time: 50.96, duration: 0, paused: true}
    insideRetinaReceptiveFieldOffCenterFiring.skully = {time: 51.5, duration: 3, paused: true}
    insideRetinaReceptiveFieldOffCenterDead.skully = {time: 51.63, duration: 1, paused: true}
    insideRetinaReceptiveFieldOnCenterFiring.skully = {time: 51.8, duration: 1, paused: true}
    insideThroughTheBrain.skully = {time: 65, duration: 3, paused: true}
    insideVisualCortex.skully = {time: 86, duration: 5, paused: true}

    When(buildInRange(insideEnterSkully, insideVisualCortex))
      .changed(((_ts, build) => build.skully && skully.seekTo(build.skully)))
  </script>

  <div id=ht2a>
    <type-writer id=ht2aTitle></type-writer>
    <video id=ht2aVideo src=5ht2a.m4v loop preload></video>
  </div>
  <div id=ht2aLSDBinding>
    <type-writer id=ht2aLSDTitle></type-writer>
    <img src=lsd-binding-lid.png>
  </div>  
  <build-note id=inside5ht2a></build-note>
  <build-note id=inside5ht2aLSDBinding></build-note>
  <script>
    When(buildInRange(inside5ht2a, inside5ht2aLSDBinding))
      .start(() => {
        ht2aTitle.text = '5-HT2 receptor subtype A'
        ht2aVideo.currentTime = 0
        ht2aVideo.playbackRate = 2
        ht2aVideo.play()
      })
    When(inside5ht2aLSDBinding)
      .start(() => ht2aLSDTitle.text = 'LSD 5-ht2a binding - EL2 "lid"')
  </script>

  <div id=adversarialSticker>
    <type-writer id=stickerTitle></type-writer>
    <video src=adversarial-sticker.m4v loop autoplay preload>
  </div>
  <div id=adversarialSkiiers>
    <type-writer id=skiiersTitle></type-writer>
    <img src=adversarial-skiiers.gif>  
  </div>
  <build-note id=insideAdversarialSticker></build-note>
  <build-note id=insideAdversarialSkiiers></build-note>
  <script>
    When(buildInRange(inside5ht2a, insideAdversarialSkiiers))
      .end(() => ht2aTitle.text = ht2aLSDTitle.text = stickerTitle.text = skiiersTitle.text = '')
    When(insideAdversarialSticker)
      .start(() => stickerTitle.text = 'Adversarial patch (arXiv:1712.09665v2)')
    When(insideAdversarialSkiiers)
      .start(() => skiiersTitle.text = 'Black-box adversarial example (arXiv:1712.07113v2)')
  </script>

  <build-note id=hallucinationsToSleep></build-note>
  <script>
    let hallucinationBuilds =
      [...hallucinations.getElementsByTagName('build-note')]
        .filter(x => !x.skully)
    When(hallucinationsToSleep)
      .start(() => titleWriter.text = '')
      .frame(every(0.1[sec]) ((_, i) => {
        const lastBuild = hallucinationBuilds[hallucinationBuilds.length - i - 2]
        const nextBuild = hallucinationBuilds[hallucinationBuilds.length - i - 3]
        if (!nextBuild) return
        document.body.classList.remove(lastBuild.id)
        document.body.classList.add(nextBuild.id)
      }))
      .end(() => document.body.classList.remove(hallucinationBuilds[0].id))
  </script>
</div>

<!-- 2. dreams -->
<div id=dreams>
  <build-note id=title2             data-title='2. '></build-note>
  <build-note id=title2Dreams       data-title='2. dreams'></build-note>

  <build-note id=title2DreamsBlur data-time=10 data-paused></build-note>
  <div id=faces>
    <video id=facesVideo src=gan-faces.mp4 class=layer is=seekable-video preload></video>
    <script>const discrim = createLayers({prefix: 'discrim', className: 'discrim-layer', count: 10})</script>
    <script>const gen = createLayers({prefix: 'gen', className: 'gen-layer', count: 10})</script>
  </div>
  <build-note id=dreamsPlaying data-time=10></build-note>
  <build-note id=dreamsTraining data-duration=1 data-time=51 data-playback-rate=0.5></build-note>
  <build-note id=dreamsTrainingExpand data-duration=10 data-playback-rate=0.1></build-note>
  <build-note id=dreamsTrainingDiscriminator data-duration=10 data-playback-rate=0.1></build-note>
  <build-note id=dreamsTrainingFeedback data-duration=10 data-playback-rate=0.1></build-note>
  <build-note id=dreamsInterpolation data-duration=2 data-time=85.5></build-note>    
  <script>
    When(buildInRange(title2DreamsBlur, dreamsInterpolation))
      .changed((_, {dataset: {time, duration=0, paused, playbackRate=1}}) =>
        facesVideo.seekTo({time, duration, playbackRate, paused: typeof paused !== 'undefined'}))      

    When(buildInRange(dreamsTraining, dreamsTrainingFeedback))
      .frame(function() {
        this.lastTime = this.lastTime || 0
        const now = Math.floor(facesVideo.currentTime * 10)
        if (this.lastTime !== now) {
          gen_9.innerHTML = `<pre>${randomMatrix(5, 5)}</pre>`
          gen_9.style.opacity = 1
          this.lastTime = now
        }
        if (facesVideo.currentTime > 78)
          facesVideo.currentTime = 47
      })
      .end(() => gen_9.style.opacity = 0)

    When(buildInRange(dreamsTrainingExpand, dreamsTrainingFeedback))
      .withDuration(20[sec])
      .start(async function() {
        this.zRot = lerp(0, 360, _ => _ % 360)
        this.xRot = lerp(0, 70)
        this.zoom = lerp(1, 0.4)
        this.expand = lerp(0, 1)
        this.panDown = For(3[sec])
          .at(t => faces.style.setProperty('--stack-rotate-x', this.xRot(t) + 'deg'))
        this.zoomOut = For(8[sec])
          .at(t => faces.style.setProperty('--stack-zoom', this.zoom(t)))
        this.expandStack = For(6[sec])
          .at(t => faces.style.setProperty('--stack-expand', this.expand(t)))
      })
      .at(function(t) {
        faces.style.setProperty('--stack-rotate-z', this.zRot(t % 1) + 'deg')
      })        
      .end(function () {
        this.panDown.remove()
        this.zoomOut.remove()
        const zReset = lerp(this.zRot(this.t % 1), 0, _ => _ + 'deg')
        const xReset = lerp(this.xRot(this.panDown.t), 0, _ => _ + 'deg')
        const zoomReset = lerp(this.zoom(this.zoomOut.t), 1)
        For(1[sec])
          .at(t => {
            faces.style.setProperty('--stack-rotate-x', xReset(t))
            faces.style.setProperty('--stack-zoom', zoomReset(t))
            faces.style.setProperty('--stack-rotate-z', zReset(t))
          })
          .end(() => {
            faces.style.setProperty('--stack-rotate-x', 0)
            faces.style.setProperty('--stack-zoom', 1)
            faces.style.setProperty('--stack-rotate-z', 0)
          })         
      })

    When(dreamsTrainingFeedback).withDuration(3[sec])
      .start(function() {
        this.expand = lerp(1, -1)
      })
      .at(function(t) {
        if (t > 1) return
        faces.style.setProperty('--discrim-stack-expand', this.expand(t))
      })
      .end(() => faces.style.setProperty('--discrim-stack-expand', 1))

    When(dreamsInterpolation)
      .frame(() => facesVideo.currentTime > 144 &&
        (facesVideo.currentTime = dreamsInterpolation.dataset.time))
  </script>

  <grid-cells id=grid></grid-cells>  
  <build-note id=dreamsGrid></build-note>
  <build-note id=dreamsGridFaster></build-note>
  <build-note id=dreamsGridFlashing></build-note>
  <build-note id=dreamsGridZoom></build-note>

  <script>
    When(dreamsGrid)
      .start(() => { grid.onResize(); grid.playbackRate = 1 })

    When(buildInRange(dreamsGridFaster, dreamsGridZoom))
      .start(() => For(2[sec]).at(t => grid.playbackRate = 100 * t))
      .end(() => grid.playbackRate = 0)
  </script>

  <build-note id=dreamsEnd></build-note>    
</div>

<!-- 3. stones -->
<div id=stones>
  <build-note id=title3 data-title='3. '></build-note>
  <build-note id=title3sticksAndStones data-title='3. sticks and stones'>
    They say you can't tickle yourself because you know it's coming.
    Specifically, when your brain sends an action command to your muscles...
  </build-note>

  <body-model id=bodyModel>
    <div id=inversion-wipe class=wipe-east-west></div>
  </body-model>
  <type-writer id=efferenceCopy></type-writer>
  <build-note id=stonesEfference data-title='efference'>
    That's called an efference
    When an efference is sent, your brain makes a copy.      
  </build-note>
  <build-note id=stonesEfferenceCopy data-title='efference'>
    "Makes a copy" sounds so... planned.
    Your brain is this big signal processing mesh.
  </build-note>
  <build-note id=stonesEfferenceReflection data-title='efference'>
    Another way to think of efference copies is as reflections.
  </build-note>
  <script>
    When(stonesEfference).start(() => efferenceCopy.text = '')
    When(stonesEfferenceCopy)
      .start(() => {
        const {width, height, bottom, left} = titleWriter.getBoundingClientRect()
        efferenceCopy.style.bottom = bottom - height + 'px'
        efferenceCopy.style.left = left + 'px'
        efferenceCopy.text = 'efference copy'
      })
  </script>
  <build-note id=stonesEfferenceMove data-title='fingers: move'>
    We take the efference...
  </build-note>
  <script>
    When(stonesEfferenceMove)
      .start(() => {
        efferenceCopy.removeAttribute('style')
        efferenceCopy.text = 'fingers: move'
      })
  </script>

  <build-note id=stonesEfferenceSend data-title='fingers: move'>
    ...and send it out to our peripheral nerves, where it will presumably
    make some muscles contract.
    Meanwhile, from the efference copy...
  </build-note>
  <build-note id=stonesTransformCopy>
    We predict how our body's state will change...
  </build-note>
  <script>
    When(stonesTransformCopy)
      .start(() => efferenceCopy.text = 'fingers will move')
  </script>
  <build-note id=stonesApplyCopy>
    And use that to update our brain's model of our body's state.
    If we <i>didn't</i> do this, the we would have to wait for
    sensory data to come back, to tell what happened. Where <i>is</i> our
    hand right now?

    But if we did that, we'd face the same problem as trying to play
    a twitchy video game over a totally crap connection. Signals take TKms
    to travel from our brain to our periphery, and another TKms to travel
    back. It's just not that low-latency or high-bandwidth, this body of ours,
    at least not neurologically.

    To enable smooth, coordinated movements, our brain has to make predictions.
  </build-note>
  <script>
    When(stonesApplyCopy)  
      .start(() => For(4[sec]).frame(every(0.1[sec])(() => {
        r_finger_pos.update()
        l_armpit_touch_pts.update()
      })))
  </script>
  <h1 id=fingersDidMove>fingers did move</h1>
  <h1 id=armpitWasTickled>armpit was tickled</h1>
  <build-note id=stonesLifeGoesOn>
    Life goes on.  
  </build-note>
  <build-note id=stonesFingersDidMove>
    But in a moment, have a problem.
    We will still receive sense data from our nerves.
    If we updated our models again, they would actually fall *out* of sync.
  </build-note>
  <build-note id=stonesFingersDidMoveAttenuated>
    So we attenuate this signal.
  </build-note>
  <build-note id=stonesLifeGoesOnAgain>
    And keep our model in sync.
  </build-note>
  <build-note id=stonesArmpitWasTickled>
    This attenuation applies to sense of touch, when that touch is an
    expected consequence of our own movement.
    Pieces of this model exist throughout the brain. That's what your brain is about,
    really.

    But one part of our brain in particular is implicated in an awful lot of prediction.
  </build-note>
  <img id=grayCerebellum src=gray-cerebellum-pink.png>
  <img id=soboCerebellum src=sobo-cerebellum-pink.png>
  <build-note id=stonesInTheCerebellum>
    The cerebellum.
  </build-note>
  <build-note id=stonesCerebellumWider>
  </build-note>
  <script>
    When(any(stonesLifeGoesOn, buildInRange(stonesLifeGoesOnAgain, stonesInTheCerebellum)))
      .frame(every(0.1[sec])(() => bodyModel.update()))
  </script>
</div>